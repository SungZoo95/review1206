# 알고리즘 기본 

# 1.가장 기본이 되는 자료구조: 스택과 큐
## 스택 자료형의 기본 구조 
리스트 1 - 5 - 7 - 9- 삭제 -5 - 1
먼저 들어온 순서는 왼쪽에 위치하며 다음에 오는 숫자는 오른쪽으로 배치 
파이썬으로는 append 함수 삭제는 pop 함수로 사용 할 수 있다. 
상위 스택부터 읽으려면 [::-1] 위부터 읽어주고 하위 스택부터 읽으려면 그냥 읽어주면 된다.

## 큐 자료구조
큐의 시각화 
삽입(5)- 삽입(2) - 삽입(3) - 삽입(7) - 삭제() - 삽입(1) -삽입(4) - 삭제() 
왼쪽에서 들어와서 오른쪽으로 배열됨 ex) 7 3 2 5 
삭제는 오른쪽부터 삭제됨 ex) 7 3 2
항상 원소는 왼쪽으로 들어온다.
삭제연산은 오른쪽부터 삭제된다. ex) 4 1 7 3

from collections import deque 라이브러리를 사용합니다.
```py
queue = deque()
queue.append(5)
queue.append(2)
queue.append(3)
queue.append(7)
queue.popleft()
queue.append(1)
queue.append(4)
queue.popleft()

print(queue) = deque([3,7,1,4]) # 먼저 들어온 순서대로 출력
queue.reverse() # 역순 
print(queue) = deque([4,1,7,3]) # 나중에 들어온 순서부터 출력
```

---

# 2. 우선순위에 따라 데이터를 꺼내는 자료구조
## 우선순위 큐 

- 우선순위 큐는 우선순위가 가장 높은 데이터를 먼저 삭제하는 자료구조이다.
- 우선순위 큐는 데이터를 운선순위에 따라 처리하고 싶을 때 사용합니다. 
    - 예시) 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건부터 꺼내서 확인해야 하는경우 

---

|자료구조 | 추출되는 데이터 |
|:-------:|:---------:|
|스택 | 가장 나중에 삽입된 데이터|
|큐 | 가장 먼저 삽입된 데이터 |
|우선순위 큐 | 가장 우선순위가 높은 데이터| 

---


- 우선순위 큐를 구현하는 방법
    - 리스트를 이용
    - heap을 이용
### 힙의 특징
- 완전 이진 트리를 가진다. (왼쪽, 오른쪽 순 자식트리)
- 최소 힙 구성 함수 : Min-Heapify() 
- 힙 원소가 제거 될 때 
- 가장 아래 자식이 부모 성질과 교체된다.
import heapq 라이브러리를 이용한다.

# 3. 활용도가 높은 자료구조 : 트리 자료구조 
## 트리 
- 계층적인 구조를 표현할 떄 사용할 수 있다.
- 트리 관련 용어
    - 루트 노드 (root node): 부모가 없는 최상위 노드
    - 단말 노트 (leaf node): 자식이 없는 노드
    - 크기 (size): 트리에 포함된 모든 노드의 개수
    - 깊이 (depth): 루트 노드부터의 거리 
    - 높이 (height): 깊이 중 최댓값
    - 차수 (degree): 각 노드의 (자식 방향) 간선 개수 
- 기본적으로 트리의 크기가 N이면, 전체 간선의 개수는 N-1개입니다. 
- 이진 탐색 트리 
    - 특징 : 왼쪽 노드 < 부모노드 < 오른쪽 노드
        - 부모 노드보다 왼쪽 자식 노드가 작습니다.
        - 부모 노드보다 오른쪽 자식 노드가 큽니다.
    
- 트리의 순회 
- 트리의 노드를 특정 방법으로 한 번씩 방문하는 방법 
    - 트리의 정보를 시각적으로 확인가능
- 트리 순회 방법
    - 전위 순회 : 루트를 먼저 방문 후 왼 오
    - 중위 순회 : 왼쪽 방문 루트 방문 오른쪽
    - 후위 순회 : 왼쪽 방문 오른쪽 방문 루트 방문 
```
    A
 B     C
D E   F G
전위 순회 : A-B-D-E-C-F-G
중위 순회 : D-B-E-A-F-C-G
후위 순회 : D-E-B-F-G-C-A
```

# 4. 특수한 목적의 자료구조 : 바이너리 인덱스 트리 
## 바이너리 인덱스 트리 (어려움)
- 2진법 인덱스 주고를 활용해 효과적으로 해결 가능
# 5. 간단하면서 기본적인 정렬 알고리즘 : 선택 정렬과 삽입 정렬
- 정렬이란 데이터를 특정한 기준에 따라 순서대로 나열하는 것을 말합니다. (sorting)
### 선택 정렬
- 처리되지 않은 데이터 중 가장 작은 데이터를 선택해서 맨 앞 데이터와 위치를 바꿉니다.
- 선택 정렬의 시간 복잡도
    - N번만큼 가장 작은 수를 찾아 앞으로 보내야합니다
### 삽입 정렬
- 처리되지 않은 데이터를 하나씩 골라 적절한 위치에 삽입합니다.
- 선택 정렬보다 난이도가 높은 편이지만, 일반적으로 효율적으로 작용합니다.
- 삽입 정렬의 시간 복잡도
    - 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우빠르게 동작합니다.
# 6 . 더 빠른 정렬 알고리즘 : 퀵 정렬과 계수 정렬
### 퀵 정렬
- 기준데이터를 설장하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 방법입니다.
- 일반적인 상황에서 제일 많이 사용되는 알고리즘 중 하나입니다.
- 병합 정렬과 더불어 대부분의 프로그래밍 언어의 정렬 라이브러리의 근간이 되는 알고리즘입니다.
- 가장 기본적인 퀵 정렬은 첫 번째 데이터를 기준 데이터로 설정합니다. 
- 퀵 정렬의 시간 복잡도 
    -피벗값에 따라 편향된 분할이 발생돼 시간이 많이 발생될 수 있다. 
    -맨 왼쪽을 피벗으로 삼고 그 좌측은 피벗보다 큰값
    우측은 피벗보다 작은값 그 두개를 비교하고 작은 수를 왼쪽으로 옮기는것을 반복 엇갈리는순간 피벗을 그 작은값이랑 자리 교체한다.(분할)
### 계수 정렬
- 특정한 조건이 부합할 때만 사용 할 수 있지만 매우 빠르게 동작하는 알고리즘이다.
- 계수 정렬은 데이터의 크기 범위가 제한되어 정수 형태로 표현 할 수 있을때 사용가능합니다.
- 데이터의 개수가  N, 데이터(양수) 중 최댓값이 K일 떄 최악의 경우에도 수행 시간 O(N+K)를 보장합니다.
- 계수 정렬의 복잡도 
    - 때에 따라서 심각한 비효율성을 초래할 수 있습니다.
    - 동일한 값을 가지는 데이터가 여러 개 등장할 때 효과적으로 사용할 수 있습니다.
# 7 . 정렬 알고리즘 비교 및 기초 문제 풀이

|정렬 알고리즘 | 평균 시간 복잡도 | 공간 복잡도 | 특징 |
|:------------:|:------------------:|:------------:|:-----:|
|선택 정렬  | O(N**2)| O(N)| 아이디어가 매우 간단합니다.|
|삽입 정렬 | O(N**2)| O(N)| 데이터가 거의 정렬되어 있으면 가장 빠릅니다.|
|퀵 정렬| O(NlogN)| O(N)| 대부분의 경우에 가장 적합하며, 충분히 빠릅니다|
|계수 정렬| O(N+k)| O(N+K) | 데이터의 크기가 한정되어 있는 경우에만 사용이 가능하지만 매우 빠르게 동작합니다.|
- 대부분의 라이브러리는 최악의 경우에도 O(logN)을 보장하도록 설계되어 있습니다. 

# 8 . 그래프  탁색의 기본, DFS와 BFS
- DFS(Depth - First - Search)는 깊이 우선 탐색이라고 부르며 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘입니다.
- DFS는 스택 자료구조(혹은 재귀함수)를 이용하며,  구체적 동작과정은 다음과 같습니다.
    1. 탐색 시작 노드를 스택에 삽입하고 방문처리를 합니다.
    2. 스택의 최상단 노드에 방문하지 않은 인접한 노드가 하나라도 있으면 그 노드를 스택에 넣고 방문 처리합니다.
    방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드를 꺼냅니다.
    3. 더 이상 2번의 과정을 수행할 수 없을 때까지 반복합니다.
- BFS(Breadth - First - Search)는 너비 우선 탐색이라고도 부르며, 그래프에서 가까운 노드부터 우선적으로 탐색하는 알고리즘 입니다.
- BFS는 큐 자료구조를 이용하며, 구체적인 동작과정은 다음과 같습니다.
    1. 탐색 시작 노드를 큐에 삽입하고 방문처리를 합니다.
    2. 큐에서 노드를 꺼낸 뒤에 해당 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리합니다.
    3. 더이상 2의 과정 수행할수 없을 때까지 반복합니다.

# 10 . 다익스트라 알고리즘: 하나의 출발지에서 다른 모든 출발지까지 최단 경로 계산
